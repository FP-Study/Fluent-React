# Chapter 6 Server-Side React
React는 빈 HTML 파일을 서버로부터 받고, 자바스크립트를 다운받고 실행해서 컨텐츠를 렌더링하는 방식인 CSR을 베이스로 한다.

## 클라이언트 사이드 렌더링의 한계
### SEO
- 다수의 검색 엔진 크롤러가 자바스크립트를 실행할 수 없어서 정확한 콘텐츠를 못 찾을수도 있다. 이 결과, 검색 엔진은 블랙 스크린이나 fallback 메세지를 보게 되서 SEO에 악영향을 끼친다.

### Performance
- 렌더링 전에 자바스크립트를 다운, 파싱, 실행하는 과정에서 느린 네트워크 혹은 CPU 성능이 떨어지는 기기라면 성능 이슈가 생길 수 있다.
- 자바스크립트 다운로드 때문에, initial 페이지 로드가 블락되서 웹 애플리케이션이 보이지 않는 문제가 발생할 수 있다. 

### Security
- 서버와 클라이언트 사이에 공유된 시크릿이나 contract가 없기 때문에(리퀘스트의 출처가 validate가 안됐다) CSRF 공격에 취약하다.

## 서버 렌더링의 부상
- **서버 사이드에서 중요한 콘텐츠들을 렌더링**해서 보내준다면, 자바스크립트의 실행과 무관하게 필수적으로 보여 줘야 하는 콘텐츠들을 유저들에게 보여줄 수도 있고, 검색 엔진이 이를 찾을 수도 있다.

### 서버 렌더링의 장점
1. first meaningful paint 시간이 빠르다.
2. 완전 렌더링이 된 HTML을 받는다면, 느린 네트워크 혹은 CPU 성능이 떨어지는 기기에서도 서버 사이드 렌더링보다 더 나은 웹 어플리케이션 접근성을 제공할 수 있다. (성능면에서 보완)
3. 완전 렌더링이 된 HTML사이트가 검색 엔진 크롤러에 더 잘 안식 되기 때문에, 검색 엔진이 사이트의 콘텐츠와 구조를 더 잘 인식할 수 있다. (SEO 강점)
4. 자바스크립트의 실행과 관계 없이 유저와 검색 엔진에게 기본적인 콘텐츠와 기능을 제공할 수 있다.

## 하이드레이션
- 자바스크립트 기능들을 정적인 HTML에 붙이는 과정
- 하이드레이션의 목적은 **서버 렌더 된 애플리케이션**이 브라우저에 로드 된 후, 완전히 interactive하게 하는 것이다.

리액트 애플리케이션에서 하이드레이션은 아래와 같은 순서로 진행된다
1. 클라이언트가 서버 렌더된 리액트 애플리케이션을 다운로드 한다.
2. 정적인 HTML을 렌더 하면서, 리액트 컴포넌트나 애플리케이션 기능을 포함하고 있는 자바스크립트 번들을 다운로드 하고 실행한다.
3. 다운로드가 끝나면, DOM 엘리멘트에 이벤트 리스너나 동적인 기능들을 붙이며 하이드레이션을 진행한다. 여기서 **리렌더링이 이루어 진다**.
4. 하이드레이션이 끝나면, 애플리케이션은 완전히 interactive하게 된다.

### Hydration Considred Harmful
- 하이드레이션 덕분에, 서버에서 렌더 된 결과물을 클라이언트로 넘겨줘서 필수로 보여줘야 하는 콘텐츠들을 우선 보여 줄 수 있다. 
- 하지만, 자바스크립트를 다운 받아서 이벤트 리스너나 기능들을 HTML에 붙이기 전까지 interactive한 동작을 할 수 없기 때문에, **TTI는 오히려 더 느려질 수 있다**.
- 서버에서 화면을 그릴 때 사용하던 상태를 클라이언트에서 이어받아서 사용한다는 resumability라는 개념을 도입하면 이를 해결할 수 있지만, 도입하기 복잡하다는 의견이 많다.

## 서버 렌더링 만들기
### 1. 클라이언트 온리 앱에 서버 렌더링 추가
- 직접 서버사이드 랜더링 역할을 수행하는 서버를 만들어서, 렌더링 된 HTML파일을 클라이언트로 보낸다.

### 2. 리액트에서의 서버 렌더링 API들 활용
1.  renderToString API
    - 서버에서 리액트 컴포넌트를 HTML 스트링으로 렌더 하도록 한다.
    - 즉, 리액트 엘리멘트의 트리를 순회하며 엘리멘트들을 리얼 DOM 엘리멘트의 string 표현으로(완전히 렌더 된 HTML string으로) 바꾼다.

    (JSX -> React.createElement -> React element -> renderToString(React element) -> HTML)
    #### 단점
    1. 동기적이기 때문에, 이벤트루프를 블락시키고, 서버를 unresponsive하게 만들어서 리액트 어플리케이션이 느려질 수 있다.
        - Netowrk I/O 동작은 비동기적이기 때문에, 동기적으로 동작하는 renderToString을 사용한다면, 서버에서 아직 완료되지 않은 파일을 클라이언트가 전달받을 가능성도 있다.
        - 다수의 클라이언트가 동시에 리퀘스트를 보낼 때, 새로운 클라이언트는 앞선 작업들이 끝날 때 까지 기다려야 한다.
    2. 전체 HTML가 생성된 후에 클라이언트로 전송되야 하기 때문에, 클라이언트가 HTML을 받기 시작하는 시간이 길어질 수 있다.


2. renderToPipeableStream API
    - 리액트 엘리먼트를 HTML 스트링으로 바꾸는 것이 아니라, Node.js stream으로 바꾼다.
    - 한 번에 모든 데이터를 메모리로 로드하는 것이 아니라, 점진적으로 다룰 수 있다. 이로 인해, 큰 string이나 data stream을 다룰 때 효과적이다.
    - 개발자가 stream울 가지고 렌더링 파이프라인을 더 쉽게 커스터마이징 할 수 있기 때문에 유연하다.
    - Suspense와 같은 리액트의 concurrent 기능들을 지원한다.

3. renderToReadableStream API
    - renderToPipeableStream이 Node.js streaming을 다룬다면, renderToReadableStream은 브라우저 streaming을 다룬다.
    -  Node.js stream은 이벤트 기반이고, 서버 사이드 실행에 잘 맞지만, 브라우저 stream은 promise 기반이고, 모던 웹 표준을 따르며, 클라이언드 실행에 잘 맞는다.


- 책에서는 동기적인 renderToString 보다는 환경에 따라서 renderToPipeableStream 혹은 renderToPipeableStream를 선택해서 사용하는 것을 권장한다.
