# 5. Common Questions and Powerful patterns



### shallow comparison

리액트는 reference check에서 그치지 않고, type check, key length, key value 까지 비교한다.

Reference check만으로도 충분하고, 나머지 연산들은 오버헤드라고 생각했는데 이유가 뭘까.?

참고: https://romgrk.com/posts/react-fast-memo/

```javascript
function shallowEqual(objA, objB) {
  if (Object.is(objA, objB)) { return true; }
  
	//type check
  if (typeof objA !== 'object' || objA === null ||
      typeof objB !== 'object' || objB === null) {
    return false;
  }

  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);

  //key length check
  if (keysA.length !== keysB.length) {
    return false;
  }

  //key value check
  for (let i = 0; i < keysA.length; i++) {
    if (!objB.hasOwnProperty(keysA[i]) || objA[keysA[i]] !== objB[keysA[i]]) {
      return false;
    }
  }

  return true;
}

```



### React compiler 출시

useMemo, useCallback, React.memo를 안 써도 필요한 부분만 리렌더링 해주는 기술

드디어 출시..!🚀



### Greater UI Control with Suspense

책에서는 lazy loading과의 조합을 설명하고 있지만, data fetching, static assets과의 궁합도 기대된다.

`use`  



### Presentationsal/Container 패턴

리액트 처음 시작할 때 들어봤지만 해괴해보여 시도해본적은 없었는데 지금 보니 약간의 concise를 희생하는 대신 로직과 ui를 분리하면서 얻는 장점도 있는 것 같다.



### Higher Order Component 

음. 예제로 볼 때는 어느 정도 관심사를 분리시켜주는 것으로 보이지만.. with가 10개라고 생각해보면 절레절레 

여러 명이 협업하는 환경에서 엉망진창이 되기 너무 쉬워보인다.

걷잡을 수 없는 디버깅은 내가 해야한다. 남이 안해준다.



### Control Props

?

### Prop Collections



### Compound Components

사용하는 곳에 더 많은 유연성을 제공한다.

props개수를 늘리는 것으로 유연성을 확보하려고 하는데, 공통 컴포넌트가 너무 다양한 props를 아는 것도 별로다. 관심사를 줄일 수 있다는 면에서 좋다고 생각한다.

너무 큰 유연성을 런타임에 제한하면 된다.(ex: item들은 content안에 쓰여야한다.)